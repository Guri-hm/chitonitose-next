const { visit } = require('unist-util-visit');

// Ruby tag placeholder storage
const rubyPlaceholders = new Map();
let rubyCounter = 0;

/**
 * Remark plugin to temporarily replace <ruby> tags with placeholders
 * This allows other text-based plugins (markers, terms) to work correctly
 */
function remarkRubyEncode() {
  return (tree) => {
    visit(tree, 'html', (node) => {
      const html = node.value;
      // Match <ruby>...</ruby> tags
      const rubyRegex = /<ruby>([^<]+)<rt>([^<]+)<\/rt><\/ruby>/g;
      
      if (rubyRegex.test(html)) {
        let newValue = html;
        newValue = newValue.replace(rubyRegex, (match, base, reading) => {
          const id = `__RUBY_${rubyCounter++}__`;
          rubyPlaceholders.set(id, match);
          return id;
        });
        node.value = newValue;
      }
    });
    
    // Also encode ruby in text nodes
    visit(tree, 'text', (node) => {
      const text = node.value;
      const rubyRegex = /<ruby>([^<]+)<rt>([^<]+)<\/rt><\/ruby>/g;
      
      if (rubyRegex.test(text)) {
        let newValue = text;
        newValue = newValue.replace(rubyRegex, (match, base, reading) => {
          const id = `__RUBY_${rubyCounter++}__`;
          rubyPlaceholders.set(id, match);
          return id;
        });
        node.value = newValue;
      }
    });
  };
}

/**
 * Remark plugin to restore <ruby> placeholders back to HTML tags
 * This should run after all text processing plugins
 */
function remarkRubyDecode() {
  return (tree) => {
    visit(tree, (node) => {
      if (node.type === 'text' && node.value) {
        const placeholderRegex = /__RUBY_\d+__/g;
        if (placeholderRegex.test(node.value)) {
          let newValue = node.value;
          for (const [id, rubyTag] of rubyPlaceholders) {
            newValue = newValue.replace(id, rubyTag);
          }
          node.value = newValue;
        }
      }
      
      if (node.type === 'html' && node.value) {
        const placeholderRegex = /__RUBY_\d+__/g;
        if (placeholderRegex.test(node.value)) {
          let newValue = node.value;
          for (const [id, rubyTag] of rubyPlaceholders) {
            newValue = newValue.replace(id, rubyTag);
          }
          node.value = newValue;
        }
      }
    });
    
    // Clear placeholders for next file
    rubyPlaceholders.clear();
    rubyCounter = 0;
  };
}

/**
 * Remark plugin to convert custom directives like :::lead, ::top, etc.
 * to HTML divs with appropriate classes
 */
function remarkCustomDirectives() {
  return (tree, file) => {
    visit(tree, (node) => {
      // Handle container directives (:::)
      if (node.type === 'containerDirective') {
        try {
          const data = node.data || (node.data = {});
          const tagName = 'div';
          
          console.log(`[remarkCustomDirectives] Processing :::${node.name} at line ${node.position?.start.line}`);
          
          data.hName = tagName;
          data.hProperties = {
            className: node.name, // lead, top, middle, last, gazo, etc.
          };
          
        // Special handling for :::gazo - add classes to images inside
        if (node.name === 'gazo' && node.children) {
          // Get size attribute from directive attributes
          const sizeClass = node.attributes?.size || '';
          
          visit(node, 'image', (imageNode) => {
            const imageData = imageNode.data || (imageNode.data = {});
            const classes = ['lazyload', 'popup-img'];
            if (sizeClass) {
              classes.push(sizeClass);
            }
            imageData.hProperties = {
              ...(imageData.hProperties || {}),
              className: classes.join(' '),
              style: 'cursor: pointer;',
            };
          });
        }          // Unwrap paragraphs - extract children from paragraph nodes
          if (node.children && node.children.length > 0) {
            const newChildren = [];
            for (const child of node.children) {
              if (child.type === 'paragraph') {
                console.log(`[remarkCustomDirectives]   Unwrapping paragraph with ${child.children?.length || 0} children`);
                // Extract paragraph's children instead of keeping the paragraph
                newChildren.push(...child.children);
              } else {
                newChildren.push(child);
              }
            }
            node.children = newChildren;
            console.log(`[remarkCustomDirectives]   Final children count: ${node.children.length}`);
          }
        } catch (error) {
          console.error(`[remarkCustomDirectives ERROR] at line ${node.position?.start.line}: ${error.message}`);
          throw error;
        }
      }
      
      // Handle leaf directives (::)
      if (node.type === 'leafDirective') {
        const data = node.data || (node.data = {});
        const tagName = 'div';
        
        console.log(`[remarkCustomDirectives] Processing ::${node.name} at line ${node.position?.start.line}`);
        
        data.hName = tagName;
        data.hProperties = {
          className: node.name, // sup, arrow, etc.
        };
      }
    });
  };
}

/**
 * Remark plugin to convert [[term]] to clickable spans
 */
function remarkTerms() {
  return (tree, file) => {
    visit(tree, 'text', (node, index, parent) => {
      if (!parent || index === null) return;
      
      const text = node.value;
      const regex = /\[\[([^\]]+)\]\]/g;
      
      if (!regex.test(text)) return;
      
      try {
        console.log(`[remarkTerms] Processing text at line ${node.position?.start.line}: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
        console.log(`[remarkTerms]   Parent type: ${parent.type}`);
        
        const newNodes = [];
        let lastIndex = 0;
        
        // Reset regex for replace
        text.replace(regex, (match, term, offset) => {
          const beforeText = text.slice(lastIndex, offset);
          if (beforeText) {
            newNodes.push({
              type: 'text',
              value: beforeText,
            });
          }
          
          console.log(`[remarkTerms]   Converting [[${term}]] to <span class="all">`);
          
          // Create a span using hast (HTML AST)
          newNodes.push({
            type: 'emphasis',
            data: {
              hName: 'span',
              hProperties: {
                className: 'all',
              },
            },
            children: [{
              type: 'text',
              value: term,
            }],
          });
          
          lastIndex = offset + match.length;
          return match;
        });
        
        const afterText = text.slice(lastIndex);
        if (afterText) {
          newNodes.push({
            type: 'text',
            value: afterText,
          });
        }
        
        if (newNodes.length > 0) {
          console.log(`[remarkTerms]   Replacing with ${newNodes.length} nodes`);
          parent.children.splice(index, 1, ...newNodes);
          return [visit.SKIP, index + newNodes.length];
        }
      } catch (error) {
        console.error(`[remarkTerms ERROR] at line ${node.position?.start.line}: ${error.message}`);
        console.error(`[remarkTerms ERROR] Text content: "${text}"`);
        throw error;
      }
    });
  };
}

/**
 * Remark plugin to convert {{text|reading}} to <ruby> tags
 * Example: {{間氷期|かんぴょうき}} → <ruby>間氷期<rt>かんぴょうき</rt></ruby>
 */
function remarkRuby() {
  return (tree) => {
    visit(tree, 'text', (node, index, parent) => {
      if (!parent || index === null) return;
      
      const text = node.value;
      const regex = /\{\{([^|}]+)\|([^}]+)\}\}/g;
      
      if (!regex.test(text)) return;
      
      const newNodes = [];
      let lastIndex = 0;
      
      // Reset regex for replace
      text.replace(regex, (match, baseText, reading, offset) => {
        const beforeText = text.slice(lastIndex, offset);
        if (beforeText) {
          newNodes.push({
            type: 'text',
            value: beforeText,
          });
        }
        
        // Create <ruby> tag structure
        newNodes.push({
          type: 'emphasis',
          data: {
            hName: 'ruby',
            hProperties: {},
          },
          children: [
            {
              type: 'text',
              value: baseText,
            },
            {
              type: 'emphasis',
              data: {
                hName: 'rt',
                hProperties: {},
              },
              children: [{
                type: 'text',
                value: reading,
              }],
            },
          ],
        });
        
        lastIndex = offset + match.length;
        return match;
      });
      
      const afterText = text.slice(lastIndex);
      if (afterText) {
        newNodes.push({
          type: 'text',
          value: afterText,
        });
      }
      
      if (newNodes.length > 0) {
        parent.children.splice(index, 1, ...newNodes);
        return [visit.SKIP, index + newNodes.length];
      }
    });
  };
}

/**
 * Remark plugin to convert ==marked text== to spans with marker class
 */
function remarkMarkers() {
  return (tree) => {
    visit(tree, 'text', (node, index, parent) => {
      if (!parent || index === null) return;
      
      const text = node.value;
      const regex = /==([^=]+)==/g;
      
      if (!regex.test(text)) return;
      
      const newNodes = [];
      let lastIndex = 0;
      
      // Reset regex for replace
      text.replace(regex, (match, markedText, offset) => {
        const beforeText = text.slice(lastIndex, offset);
        if (beforeText) {
          newNodes.push({
            type: 'text',
            value: beforeText,
          });
        }
        
        // Create a span using hast (HTML AST)
        newNodes.push({
          type: 'emphasis',
          data: {
            hName: 'span',
            hProperties: {
              className: 'marker',
            },
          },
          children: [{
            type: 'text',
            value: markedText,
          }],
        });
        
        lastIndex = offset + match.length;
        return match;
      });
      
      const afterText = text.slice(lastIndex);
      if (afterText) {
        newNodes.push({
          type: 'text',
          value: afterText,
        });
      }
      
      if (newNodes.length > 1) {
        parent.children.splice(index, 1, ...newNodes);
        return index + newNodes.length;
      }
    });
  };
}

/**
 * Remark plugin to convert **red text** to red font
 */
function remarkRedText() {
  return (tree) => {
    visit(tree, 'strong', (node, index, parent) => {
      if (!parent || index === null) return;
      
      // Get the text content
      const textNode = node.children[0];
      if (!textNode || textNode.type !== 'text') return;
      
      // Convert to red text using hast data
      const newNode = {
        type: 'emphasis',
        data: {
          hName: 'font',
          hProperties: {
            color: '#FF0000',
          },
        },
        children: [{
          type: 'text',
          value: textNode.value,
        }],
      };
      
      parent.children[index] = newNode;
    });
  };
}

/**
 * Remark plugin to handle custom image syntax with classes
 * ![](img/2/1.svg){.twice}
 */
function remarkCustomImages() {
  return (tree) => {
    visit(tree, 'image', (node, index, parent) => {
      if (!parent || index === null) return;
      
      // Check if there's a class specification after the image
      const nextNode = parent.children[index + 1];
      if (nextNode && nextNode.type === 'text' && nextNode.value.startsWith('{.')) {
        const classMatch = nextNode.value.match(/^\{\.([^}]+)\}/);
        if (classMatch) {
          const className = classMatch[1];
          const data = node.data || (node.data = {});
          data.hProperties = {
            ...(data.hProperties || {}),
            className: `lazyload popup-img ${className}`,
          };
          
          // Remove the class specification from the text node
          nextNode.value = nextNode.value.replace(/^\{\.([^}]+)\}/, '').trim();
          if (!nextNode.value) {
            parent.children.splice(index + 1, 1);
          }
        }
      } else {
        // Default classes
        const data = node.data || (node.data = {});
        data.hProperties = {
          ...(data.hProperties || {}),
          className: 'lazyload popup-img',
        };
      }
    });
  };
}

/**
 * Remark plugin to handle ---arrow--- dividers
 */
function remarkArrows() {
  return (tree) => {
    visit(tree, 'paragraph', (node, index, parent) => {
      if (!parent || index === null) return;
      
      // Check if paragraph contains only "---arrow---"
      if (node.children.length === 1 && 
          node.children[0].type === 'text' && 
          node.children[0].value.trim() === '---arrow---') {
        const newNode = {
          type: 'html',
          value: '<div class="arrow"></div>',
        };
        
        parent.children[index] = newNode;
      }
    });
  };
}

/**
 * Remark plugin to add class="en" to unordered lists containing :::lead directives
 */
function remarkListClasses() {
  return (tree) => {
    visit(tree, 'list', (node) => {
      // Check if list contains any :::lead directives
      let hasLeadDirective = false;
      visit(node, 'containerDirective', (childNode) => {
        if (childNode.name === 'lead') {
          hasLeadDirective = true;
        }
      });
      
      if (hasLeadDirective && node.ordered === false) {
        const data = node.data || (node.data = {});
        data.hProperties = {
          ...(data.hProperties || {}),
          className: 'en',
        };
        
        // Unwrap paragraphs in list items
        visit(node, 'listItem', (listItem) => {
          if (listItem.children && listItem.children.length > 0) {
            const newChildren = [];
            for (const child of listItem.children) {
              if (child.type === 'paragraph') {
                // Extract paragraph's children
                newChildren.push(...child.children);
              } else {
                newChildren.push(child);
              }
            }
            listItem.children = newChildren;
          }
        });
      }
    });
  };
}

module.exports = {
  remarkRubyEncode,
  remarkRubyDecode,
  remarkCustomDirectives,
  remarkTerms,
  remarkRuby,
  remarkMarkers,
  remarkRedText,
  remarkCustomImages,
  remarkArrows,
  remarkListClasses,
};
